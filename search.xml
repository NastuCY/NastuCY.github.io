<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js运行机制]]></title>
    <url>%2F2019%2F02%2F13%2Fjs%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[大纲 进程与线程 浏览器是多进程的 浏览器包含哪些进程 多进程的优势 浏览器内核(渲染过程) Browser进程与浏览器内核（Renderer进程）的通信过程 梳理浏览器内核中线程的关系 GUI渲染线程与JS引擎线程互斥 JS阻塞页面加载 WebWorker,JS的多线程？ WebWorker与SharedWorker 浏览器的渲染过程 load事件与DOMContentLoaded事件的先后 css加载是否会阻塞dom树的渲染 普通图层和复合图层 从EvenLoop谈Js的运行机制 事件循环机制的进一步说明 单独说说定时器 setTimeout而不是setInterval 事件循环进阶：macrotask与microtask 区分线程与进程先看下进程与线程的一个比喻： 进程是一个独立的工厂，工厂有他独立的资源工厂之间相互独立线程是工厂里的工人,多个工人协同完成任务工厂内有一个或多个工人工人之间共享空间 完善一下： 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）工厂之间相互独立 -&gt; 进程之间相互独立多人协作共同完成任务 -&gt; 多个线程在进程中协作完成任务工厂内有一个或多个工人 -&gt; 一个进程有一个或多个线程组成工人之间共享空间 -&gt; 同一个进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等） 用官方一点的话进行总结是： 进程是CPU进行资源分配的最小单位（系统会给他分配内存），是能拥有资源和独立运行的最小单位 线程是CPU调度的最小单位（线程是建立在进程基础上的一次程序运行单位，一个进程可以有多个线程） tips 不同进程之间也可以通信，不过代价比较大 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。 浏览器是多线程的理解了进程与线程的区别后，接下来对浏览器进行一定程度的认识,先看下简化理解： 浏览器是多进程的 浏览器之所以能够运行，是因为系统给他的进程分配了资源（cpu、内存） 简单点理解，每打开一个tab页，就相当于创建了一个独立的浏览器进程。 注意:浏览器也有自己的优化机制，多个空白tab页打开后，会被合并。 浏览器包含了哪些进程?主要进程有：1.Browser进程：浏览器的主要进程（负责协调、主控）之有一个，作用有： 负责浏览器的页面展示 ，与用户交互，如前进、后退等。 负责各个页面的管理，创建和销毁其他进程。 将Renderer进程得到的内存中的Bitmap，绘制到用户界面。 网络资源的管理，下载等 2.第三方插件进程：每种类型的插件对应一个进程，仅当使用改插件时才创建。3.GPU进程：最多一个，用于3D绘制等。4.浏览器渲染进程：（浏览器内核）（Renderer进程，内部是多线程的）默认每个Tab页是一个进程，互不影响，主要作用为： 页面渲染，脚本执行，事件处理等。 在浏览器打开一个网页相当于起了一个进程（进程内有自己的多线程）。 浏览器多线程的优势相比于单线程的浏览器，多线程浏览器有以下优势： 避免单个page crash(页面崩溃)影响整个浏览器。 避免第三方插件崩溃影响整个浏览器。 多线程充分利用多核优势。 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性。 内存消耗有点大。空间换时间。 浏览器内核对于前端来说，最重要的进程是浏览器的渲染进程。页面的渲染，JS的执行，事件的循环，都在这个进程内执行。 请牢记，浏览器的渲染进程是多线程的。 浏览器的渲染进程包含哪些线程？（列一些常驻的）1.GUI渲染线程 负责渲染浏览器页面，解析HTML,CSS, 构建DOM树和RenderObject树，布局和重绘等。 当界面需要重绘（Repaint,样式改变）或由于某些操作引发回流（reflow）时，该线程就会执行。 注意，GUI渲染线程与JS引擎线程是互斥的，当js引擎执行时GUI线程会被挂起，（相当于被冻结了），GUI更新会被保存在一个队列中，等到JS引擎空闲时立即执行。 2.JS引擎线程 也称作JS内核，负责处理Javascript脚本程序（例如V8引擎）。 JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待任务队列中任务的到来，然后加以处理,一个Tab页（Renderer进程）中无论什么时候都只有一个JS线程在运行JS程序。 同样注意：GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行时间过程，就会造成页面渲染不连贯，导致页面渲染加载阻塞。 3.事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环。（可以理解为，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如SetTimeout时（也可以来自于浏览器的其他线程，如鼠标点击，Ajax请求等），会将对应任务添加到事件线程中。 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。 由于JS的单线程关系，所有这些待处理队列中的事件都得排队等待JS引擎处理。（当JS引擎空闲时才会去执行） 4.定时器触发线程 传说中的setTimeout与setInterval所在线程。 浏览器定时计数器并不是由js引擎计数的（因为js引擎是单线程的，如果处于阻塞线程状态就会影响计数的准确性） 因此通过单独的线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C与HTML标准中规定，规定要求setTimeout低于4ms的时间间隔算为4ms。 5.异步http请求线程 在XMLHttpRequest在连接之后通过浏览器新开一个线程请求。 在检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JS引擎执行。 为什么JS引擎是单线程的？ 假设JS引擎是多线程的，现在有两个进程，processA、processB,现在要对同一个dom进行操作，同时进行操作，processA编辑了该dom，processB删除了该dom，同时下达了两个矛盾的命令，浏览器该如何执行？ Browser进程（控制进程）和浏览器内核（Renderer进程）的通信过程先打开任务管理器，然后打开一个浏览器，可以看到：任务管理器中出现了两个进程（一个是主控进程，一个是打开Tab页的渲染进程）看下简化后的通信过程： Browser进程收到用户请求，首先要获取页面内容（比如通过网络下载资源），然后将该任务通过RendererHost接口传递给Render进程。 Renderer进程的Renderer接口接收到消息，简单解释后，交给渲染线程，然后开始渲染 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染。 可能有JS线程操作DOM（可能造成回流并重绘）。 最后Renderer进程将结果返回给Browser进程。 Browser进程接收到结果并将结果绘制出来。 一张简单的流程图： 梳理浏览器内核中线程之间的关系GUI渲染线程与JS引擎线程互斥由于JS是可以直接操作dom的，如果修改这些元素属性的同时渲染页面（即JS线程和UI线程同时运行），那么渲染线程前后获取的元素属性可能就不一样了。因此，为了防止不可渲染时出现不可预期的后果，浏览器设置GUI渲染线程与JS引擎为互斥关系，当JS引擎执行时，GUI线程会被挂起，GUI线程会被保存到一个待执行队列中等待JS引擎线程空闲时立即被执行。 JS阻塞页面加载从上述的互斥关系中，我们可以推导出，JS如果执行时间过长，会阻塞页面的渲染。尽量避免JS执行时间过长。 WebWorker,js的多线程？JS对cpu密集型计算如何执行？HTML5 中引入了Web WorkerMDN的官方解释是： Web Worker为web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。一个worker是使用一个构造函数创建的一个对象（e.g.Worker()）运行一个命名的Javascript文件。这个文件包含将在工作线程中运行的代码；workers运行在另一个全局上下文中，不同于当前window。因此，使用window快捷方式获取当前全局的范围（而不是self）在一个worker内将返回错误。 这样理解下： 创建Worker时，JS引擎像浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM） JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据） 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只等待计算结果出来后，将结果通信给主线程即可。 Worker可以理解是浏览器给JS引擎专门为大量计算问题开的小灶。 WebWorker与SharedWorker WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的Javascript程序。 SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现。因为它不隶属于某个Render进程，可以为多个Render进行共享使用。 所以Chrome浏览器为SharedWorker单独创建一个进程来运行Javascript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管他被创建多少次。 两个本质上就是线程与进程的区别。SharedWorker由独立的进程管理，WebWorker只是隶属与render进程下的一个线程。 简单梳理下浏览器渲染流程这个呢，渲染过程的前戏比较长，具体可以看下这个从输入 URL 到页面加载完成的过程中都发生了什么事情？可以省略概括为： 浏览器输入url,浏览器主进程接管，开一个下载线程，然后进行http请求（略去DNS查询，IP寻址等操作），然后等待响应，获取内容，然后将内容通过RendererHost接口转交给Renderer进程，然后浏览器渲染开始。 浏览器内核拿到内容后，渲染大概可以划分成以下步骤： 1.解析HTML构建DOM树； 2.解析CSS构建render树，（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）； 3.布局render树（Layout/reflow）,负责各元素尺寸、位置的计算； 4.绘制render树（paint）,绘制页面像素信息； 5.浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。详细的步骤已经略去，渲染完毕后就是load事件，之后就是自己的JS逻辑处理了。提一下这其中需要注意的一些细节。重绘与重排网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断渲染。以下三种情况，会导致网页重新渲染： 修改DOM 修改样式表 用户事件（鼠标悬停，页面滚动，输入框键入文字，改变窗口大小等等） 重新渲染，就需要重新生成布局和重新绘制，前者叫‘重排（reflow）’，后者叫‘重绘（repaint）’。 需要注意的是，‘重绘’不一定需要‘重排’，比如改变某个网页元素的颜色，就只会触发‘重绘’，不会触发‘重排’，因为布局没有改变。但是，**‘重排’必然导致‘重绘’，比如改变一个元素的位置，就会同时触发‘重排’和‘重绘’，因为布局改变了。 关于性能优化（后续补充） load事件与DOMContentLoaded事件的先后渲染完毕后会触发load事件，那么，load事件与DOMCotentLoaded事件的先后么？它们的定义如下： 当DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片。（比如如果有async加载的脚本就不一定完成） 当onload事件触发时，页面上的所有DOM，样式表，脚本，图片都已经加载完成了。 所以，两者的顺序是：DOMContentLoaded -&gt; load CSS加载是否会阻塞DOM树渲染？说下头部引入CSS样式的情况首先，我们都知道：CSS是由单独的下载线程异步下载的。然后，再说以下几个现象： CSS加载不会阻塞DOM树解析（异步加载时DOM照常构建） 但会阻塞render树渲染（渲染时等待css加载完毕，因为render树需要CSS信息） 这可能也是浏览器的一种优化机制。 当你加载css的时候，可能会修改下面DOM节点的样式，如果CSS加载不阻塞render树渲染的话，那么当css加载完成之后，render树可能又得重新重绘或者回流了。这样就造成了一些不必要的损耗。所有干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完成之后，再根据最终的样式来渲染render树，这种做法性能方面会比较好一点。 普通图层和复合图层渲染步骤中提到了composite概念。可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层和复合图层。 首先，普通文档流内可以理解为一个复合图层（这里称为默认符合层，里面不管添加多少元素，其实都是在一个复合图层中） 其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍属于默认复合图层。 然后，可以通过硬件加速的方式，声明一个新的复合图层，他会单独分配资源（当然也会脱离普通文档流，这样一个，不管这个复合图层中怎么变化，也不会影响默认复合层的回流重绘） 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒。 可以在Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders中看到，黄色的就是复合图层信息。 如何变成复合图层（硬件加速）将该元素编程一个复合图层，就是传说中的硬件加速技术。 最常用的方式：translated3d、translateZ opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态） will-change属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其他属性并不会变成复合层） 作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放） &#60;video&#62;&#60;iframe&#62;&#60;webgl&#62;等元素 其他，比如以前的falsh插件 absolute和硬件加速的区别可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树。但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）而硬件加速直接就是另一个复合层了，（另起炉灶）所以它的信息改变不会影响默认复合层（内部肯定会影响属于自己的复合层），仅仅引发最后的合成。（输出视图） 复合图层的作用？一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变得更卡。 硬件加速时请使用z-index使用硬件加速时，请尽量可能的使用z-index，防止浏览器默认给后续的元素创建复合层渲染。 具体原理：wekit CSS3中，如果这个元素添加了硬件加速，并且z-index层级过低，那么在这个元素后面的其他元素（层级比这个元素高，或者相同的，并且releative或absolute属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能。 简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转化为一个复合图层。 具体分析可参考这个连接 http://web.jobbole.com/83575/ 从Event Loop谈JS的运行机制下面对JS引擎的一些运行机制进行分析。 注意，这里不谈可执行上下文，VO，scop chain等概念，这里主要结合Event Loop来谈JS代码是如何执行的。 读到这里之前已经了解到了JS引擎是单线程的，而且这里会用到上文中的几个概念： JS引擎线程 事件触发线程 定时器线程 然后在理解一些概念： JS分为同步任务和异步任务 同步任务都是在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其他代码。 事件循环机制进一步补充借助一张图来协助理解：上图大致描述是： 主线程运行时会产生执行栈。 栈中的代码调用某些API时，他们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕） 而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调 如此循环 注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件 单独说说定时器上述事件循环机制的核心是：JS引擎线程和事件触发线程但事实上，还有一些隐藏的细节，比如调用setTimeout后，是如何等待特定时间后才添加到事件队列中的？是JS引擎检测的么？当然不是了。它是由定时器线程控制的。为什么要单独的定时器线程？因为javascript引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确性，因此很有必要单独开一个线程用来计时。 什么时候会用到定时器线程？当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。 比如：123setTimeout(function()&#123; console.log('11');&#125;,1000) 这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行。 12345setTimeout(function()&#123; console.log('hello!');&#125;, 0);console.log('begin'); 这段代码的效果是最快时间内将回掉函数推入事件队列中，等待主线程执行。 注意： 执行结果是：先begin后hello! 虽然代码的本意是0毫秒后推入事件队列，但是W3C在HTML标准中规定，要求setTimeout中低于4ms的时间间隔算为4ms。 （不过也有一说是不同浏览器有不同的最小时间设定） 就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin(因为只有可执行栈空了后才会主动读取事件队列) setTimeout而不是setInterval用setTimeout模拟定时器时和直接用setInterval是有区别的。因为每次setTimeout计时到后就回去执行，然后执行一段时间后才会继续setTimeout,中间就多了误差（误差与代码执行时间有关）而setInterval则是每次都精确的间隔一个时间推入一个事件。（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了） 而且setInterval有一些比较致命的问题就是： 累计效应（上面提到的），如果setInterval代码再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔。就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一段时间） 而且把浏览器最小化显示等操作时，setInterval并不是执行程序，它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行。 所以，鉴于这么多的问题，目前一般认为最佳的解决方案为：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame 补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加，不过，仍然有很多的问题。 事件循环进阶：macrotask和microtask先看下下面的这道题：12345678910111213console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 它的正确执行顺序是：12345script startscript endpromise1promise2setTimeout Promise里有一个新的概念：microtask或者，进一步，JS中分为两种任务类型：macrotash和microtask，在ECMA中，microtask称为jobs,macrotask可称为task。 它们的定义跟区别简单点可以按如下理解： mactask(又称为宏任务)，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行） 每一个task从头到尾将这个任务执行完毕，不会执行其他的 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个task执行开始前，对页面进行重新渲染。（task -&gt; 渲染 -&gt; task -&gt; …） microtask(又称为微任务)，可以理解是在当前task执行结束后立即执行的任务。 也就是说，在当前task任务后，下一个task之前，在渲染之前。 所以它的相应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染 也就是说，在某一个macrotask执行完毕之后，将会在它执行期间产生的所有microtask都执行完毕（在渲染前） 分别什么样的场景会形成macrotask和microtask呢？ macrotask：主代码块，setTimeout,setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask） microtask：Promise，process.nextTick等。 补充：在node环境下，process.nextTick的优先级高于Promise,也就是可以简单理解为:在宏任务结束后会执行微任务队列中的nextTickQueue部分，然后才执行微任务中的Promise部分。 再根据线程理解下： macrotask中的事件都是放在一个事件队列里的，而这个队列有事件触发线程维护 microtask中的所有微任务都是添加到微任务队列（Job Queues）中的，等待当前macrotask执行完毕后执行，这个队列由JS引擎线程维护， 所以，总结下运行规则： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 如图： 另外，请注意下Promise的polyfill与官方版本的区别： 官方版本中，是标准的microtask形式。 polyfill,一般都是通过setTimeout模拟的，所以是macrotask形式 请特别注意两者的区别。 注意，有些浏览器执行结果不一样，（因为他们可能吧microtask当成macrotask来执行了），但是为了简单，这里不描述一些不标准浏览器下的场景。 补充：使用MutationObserver实现microtask MutationObserver可以用来实现microtask（它属于mocrotask，优先级小于Promise，一般Promise不支持时才会这样做） 它是Html5中的新特性，作用是：监听一个DOM变动，当DOM对象发生任何变动时，Mutation Observer会得到通知。VUE核心代码采用是这种策略。 原文链接：https://segmentfault.com/a/1190000012925872]]></content>
      <tags>
        <tag>js</tag>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node]]></title>
    <url>%2F2019%2F02%2F05%2Fnode%2F</url>
    <content type="text"><![CDATA[什么是NodeJs 编写高性能网络服务器的Javascript工具包(用JS开发服务端程序) 单线程、异步、事件驱动 特点：快，耗内存多 网上一个百万级并发测试，未优化的情况下1M的链接消耗了16G的内存]]></content>
      <tags>
        <tag>node</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js对象方法总结]]></title>
    <url>%2F2019%2F01%2F12%2Fjs%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Object.assign()通过复制一个或多个对象来创建一个新的对象。Object.create()使用指定的原型对象和属性创建一个新对象。Object.defineProperty()给对象添加一个属性并指定该属性的配置。Object.defineProperties()给对象添加多个属性并分别指定它们的配置。Object.entries()返回给定对象自身可枚举属性的[key, value]数组。Object.freeze()冻结对象：其他代码不能删除或更改任何属性。Object.getOwnPropertyDescriptor()返回对象指定的属性配置。Object.getOwnPropertyNames()返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。Object.getOwnPropertySymbols()返回一个数组，它包含了指定对象自身所有的符号属性。Object.getPrototypeOf()返回指定对象的原型对象。Object.is()比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。Object.isExtensible()判断对象是否可扩展。Object.isFrozen()判断对象是否已经冻结。Object.isSealed()判断对象是否已经密封。Object.keys()返回一个包含所有给定对象自身可枚举属性名称的数组。Object.preventExtensions()防止对象的任何扩展。Object.seal()防止其他代码删除对象的属性。Object.setPrototypeOf()设置对象的原型（即内部[[Prototype]]属性）。Object.values()返回给定对象自身可枚举值的数组。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Object</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组方法总结]]></title>
    <url>%2F2018%2F08%2F12%2Fjs%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结的一些常用数组方法1. join()方法2. push()和pop()方法3. shift()和unshift()方法4. sort()方法5. reserve()方法6. concat()方法7. slice()方法8. splice()方法9. indexOf()和lastIndexOf()方法10. forEach()方法11. map()方法12. filter()方法13. every()方法14. some()方法15. reduce()和reduceRight()方法16. ES6对数组的拓展 1. join将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。1234var arr = [1,2,3];console.log(arr.join()); // 1,2,3console.log(arr.join("-")); // 1-2-3console.log(arr); // [1, 2, 3]（原数组不变） join() 方法，不会改变数组！返回值: 一个所有数组元素连接的字符串。如果 arr.length 为0，则返回空字符串 2. push和poppush(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。 1234567var arr = ["Lily","lucy","Tom"];var count = arr.push("Jack","Sean");console.log(count); // 5console.log(arr); // ["Lily", "lucy", "Tom", "Jack", "Sean"]var item = arr.pop();console.log(item); // Seanconsole.log(arr); // ["Lily", "lucy", "Tom", "Jack"] 3. shift和unshiftshift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。unshift():将参数添加到原数组开头，并返回数组的长度 。 1234567var arr = ["Lily","lucy","Tom"];var count = arr.unshift("Jack","Sean");console.log(count); // 5console.log(arr); //["Jack", "Sean", "Lily", "lucy", "Tom"]var item = arr.shift();console.log(item); // Jackconsole.log(arr); // ["Sean", "Lily", "lucy", "Tom"] 4. sortsort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面，默认排序顺序是根据字符串Unicode码点。 参数compareFunction | 可选用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 “80” 要比 “9” 要靠前 如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素： 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）； 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 比较函数格式如下：12345678910function compare(a, b) &#123; if (a &lt; b ) &#123; // 按某种排序标准进行比较, a 小于 b return -1; &#125; if (a &gt; b ) &#123; return 1; &#125; // a must be equal to b return 0;&#125; 要比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列 123456789101112var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b) &#123; return a - b;&#125;);console.log(numbers);也可以写成：var numbers = [4, 2, 5, 1, 3]; numbers.sort((a, b) =&gt; a - b); console.log(numbers);// [1, 2, 3, 4, 5] 对象也可按照某个属性进行排序 返回值排序后的数组。请注意，数组已原地排序，并且不进行复制。 5. reservereverse()：反转数组项的顺序。 6. concatconcat(): 将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。 实现的是数组的浅拷贝。 7. sliceslice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。 参数begin | 可选 从该索引处开始提取原数组中的元素（从0开始）。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin，则 slice 从索引 0 开始。 end | 可选 在该索引处结束提取原数组元素（从0开始）。slice会提取原数组中索引从 begin 到 end 的所有元素（包含begin，但不包含end）。slice(1,4) 提取原数组中的第二个元素开始直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1)表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。如果 end 被省略，则slice 会一直提取到原数组末尾。如果 end 大于数组长度，slice 也会一直提取到原数组末尾 返回值 一个含有提取元素的新数组。 8. splicesplice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。 参数 array.splice(start[, deleteCount[, item1[, item2[, …]]]]) 返回值 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组 12345678910var arr = [1,3,5,7,9,11];var arrRemoved = arr.splice(0,2);console.log(arr); //[5, 7, 9, 11]console.log(arrRemoved); //[1, 3]var arrRemoved2 = arr.splice(2,0,4,6);console.log(arr); // [5, 7, 4, 6, 9, 11]console.log(arrRemoved2); // []var arrRemoved3 = arr.splice(1,1,2,4);console.log(arr); // [5, 2, 4, 4, 6, 9, 11]console.log(arrRemoved3); //[7] splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 9. indexOf和lastIndexOfindexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。 123456var arr = [1,3,5,7,7,5,3,1];console.log(arr.indexOf(5)); //2console.log(arr.lastIndexOf(5)); //5console.log(arr.indexOf(5,2)); //2console.log(arr.lastIndexOf(5,4)); //2console.log(arr.indexOf("5")); //-1 10. forEachforEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；值对应的数组索引，数组本身。 参数callback为数组中每个元素执行的函数，该函数接收三个参数： currentValue数组中正在处理的当前元素。index | 可选数组中正在处理的当前元素的索引。array | 可选forEach()方法正在操作的数组。 thisArg | 可选可选参数。当执行回调 函数时用作this的值(参考对象)。 返回值undefined 注意： 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。如果你需要这样，使用forEach()方法是错误的，你可以用一个简单的循环作为替代。如果您正在测试一个数组里的元素是否符合某条件，且需要返回一个布尔值，那么可使用 Array.every 或 Array.some。如果可用，新方法 find() 或者findIndex() 也可被用于真值测试的提早终止。 如果数组在迭代时被修改了，则其他元素会被跳过。12345678910var words = ["one", "two", "three", "four"];words.forEach(function(word) &#123; console.log(word); if (word === "two") &#123; words.shift(); &#125;&#125;);// one// two// four forEach()不会在迭代之前创建数组的副本。 11. mapmap(): 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 参数callback生成新数组元素的函数，使用三个参数： currentValuecallback 数组中正在处理的当前元素。index | 可选callback 数组中正在处理的当前元素的索引。array | 可选callback map 方法被调用的数组。 thisArg | 可选执行 callback 函数时使用的this 值。 返回值一个新数组，每个元素都是回调函数的结果。 map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。map()同forEach()一样，无法跳出循环。 12. filterfilter():“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。 参数callback用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。返回true表示保留该元素（通过测试），false则不保留。使用三个参数： element当前在数组中处理的元素。index | 可选正在处理的当前元素的索引。array | 可选调用了filter的数组。 thisArg | 可选执行 callback 函数时使用的this 值。 返回值一个新的通过测试的元素的集合的数组，如果没有通过测试则返回空数组 filter 不会改变原数组，它返回过滤后的新数组。filter 遍历的元素范围在第一次调用 callback 之前就已经确定了。在调用 filter 之后被添加到数组中的元素不会被 filter 遍历到。如果已经存在的元素被改变了，则他们传入 callback 的值是 filter 遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。 12345678const fruits = ['apple', 'banana', 'grapes', 'mango', 'orange'];const filterItems = (query) =&gt; &#123; return fruits.filter((el) =&gt; el.toLowerCase().indexOf(query.toLowerCase()) &gt; -1 );&#125;console.log(filterItems('ap')); // ['apple', 'grapes']console.log(filterItems('an')); // ['banana', 'mango', 'orange'] 13. everyevery()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。 1234567function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true every 不会改变原数组。every 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。every 和数学中的”所有”类似，当所有的元素都符合条件才返回true。另外，空数组也是返回true。(空数组中所有元素都符合给定的条件，注：因为空数组没有元素)。 14. somesome()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。 12[2, 5, 8, 1, 4].some(x =&gt; x &gt; 10); // false[12, 5, 8, 1, 4].some(x =&gt; x &gt; 10); // true some() 被调用时不会改变数组。 15 reduce和reduceRight这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值(initialValue)。 初始值可为[] 或者 {} 传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。 12345678const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15 数组去重 12345678let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];let result = arr.sort().reduce((init, current)=&gt;&#123; if(init.length===0 || init[init.length-1]!==current)&#123; init.push(current); &#125; return init;&#125;, []);console.log(result); //[1,2,3,4,5] 功能型函数管道 12345678910111213141516171819202122// Building-blocks to use for compositionconst double = x =&gt; x + x;const triple = x =&gt; 3 * x;const quadruple = x =&gt; 4 * x;// Function composition enabling pipe functionalityconst pipe = (...functions) =&gt; input =&gt; functions.reduce( (acc, fn) =&gt; fn(acc), input);//根据输入值，按顺序执行传入的函数，第一个函数的返回值当作第二个函数的参数值传入// Composed functions for multiplication of specific valuesconst multiply6 = pipe(double, triple);const multiply9 = pipe(triple, triple);const multiply16 = pipe(quadruple, quadruple);const multiply24 = pipe(double, triple, quadruple);// Usagemultiply6(6); // 36multiply9(9); // 81multiply16(16); // 256multiply24(10); // 240 16. ES6对数组的拓展16.1 拓展运算符复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。修改克隆数组，同时会导致原数组改变。 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 合并数组123456789const arr1 = ['a', 'b'];const arr2 = ['c'];const arr3 = ['d', 'e'];// ES5 的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 两种方法都为浅拷贝。 与解构赋值结合1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 字符串 扩展运算符还可以将字符串转为真正的数组。 12[...'hello']// [ "h", "e", "l", "l", "o" ] 实现了 Iterator 接口的对象Map 和 Set 结构，Generator 函数16.2 Array.from()Array.from()用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 数组去重合并 1234567function combine()&#123; let arr = [].concat.apply([], arguments); //没有去重复的新数组 return Array.from(new Set(arr));&#125; var m = [1, 2, 2], n = [2,3,3]; console.log(combine(m,n)); 16.3 Array.of()Array.of方法用于将一组值，转换为数组。创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 16.4 copyWithin()copyWithin()方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接收三个参数: target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 参数target,start和end 必须为整数。如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。copyWithin方法不要求其this值必须是一个数组对象；除此之外，copyWithin是一个可变方法，它可以改变this对象本身，并且返回它，而不仅仅是它的拷贝。copyWithin 就像 C 和 C++ 的 memcpy 函数一样，且它是用来移动 Array 或者 TypedArray 数据的一个高性能的方法。复制以及粘贴序列这两者是为一体的操作;即使复制和粘贴区域重叠，粘贴的序列也会有拷贝来的值。copyWithin 函数是设计为通用的，其不要求其 this 值必须是一个数组对象。The copyWithin 是一个可变方法，它不会改变 this 的 length，但是会改变 this 本身的内容，且需要时会创建新的属性。 1234567891011[1, 2, 3, 4, 5].copyWithin(-2);// [1, 2, 3, 1, 2][1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 4);// [4, 2, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(-2, -3, -1);// [1, 2, 3, 3, 4] 16.5 find() 和 findIndex()find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 1234567891011121314[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2//接收第二个参数，用来绑定回调函数的this对象。function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: 'John', age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 16.6 fill()fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。返回修改后的数组。 接收三个参数： value :用来填充数组元素的值。 start | 可选 起始索引，默认值为0。 end | 可选 终止索引，默认值为 this.length。 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 16.7 entries()，keys() 和 values()三个方法都用于对数组的遍历。keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 不适用for...of遍历的情况下，可以手动调用遍历器对象的next方法，进行遍历12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 16.8 includes()includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 arr.includes(searchElement, fromIndex) searchElement 需要查找的元素值。 fromIndex | 可选 从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length - fromIndex 的索引开始搜索。默认为 0。 12345[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, NaN].includes(NaN); // true 16.9 flat()和flatMap()flat() 方法会递归到指定深度将所有子数组连接，并返回一个新数组。 var newArray = arr.flat(depth) depth | 可选 指定嵌套数组中的结构深度，默认值为1。参数为Infinity时表示不管嵌套多少层，都转为一维数组。 flatMap()方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但flatMap通常在合并成一种方法的效率稍微高一些。 var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素}[, thisArg]) 123456789101112131415[1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5]// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8]//flatMap等价与reduce与concatvar arr1 = [1, 2, 3, 4];arr1.flatMap(x =&gt; [x * 2]);// 等价于arr1.reduce((acc, x) =&gt; acc.concat([x * 2]), []);// [2, 4, 6, 8] 如果原数组有空位，flat()方法会跳过空位。 16.10 数组的空位 forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 ES6 则是明确将空位转为undefined。 参考链接1.MDN Array2.阮一峰ECMAScript 6 入门]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES6</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试文章]]></title>
    <url>%2F2018%2F01%2F12%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js基础]]></title>
    <url>%2F2017%2F07%2F22%2Fjs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[动态类型JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据。 数据类型最新的 ECMAScript 标准定义了 7 种数据类型: 6 种原始类型: Boolean有两个字面值 true和false Null值 null 是一个字面量，它不像undefined 是全局对象的一个属性。null 是表示缺少的标识，指示变量未指向任何对象。把null 作为尚未创建的对象，也许更好理解。在 APIs 中，null 常在返回类型是对象，但没关联值的地方使用。null表示一个空指针对象。 Undefined 一个没有被赋值的变量的类型是undefined，如果方法 Number String Symbol (ECMAScript 6 新定义) 和 Object 使用 typeof 操作符判断对象类型 # 参考链接1.MDN Array]]></content>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css笔记]]></title>
    <url>%2F2016%2F10%2F12%2Fcss%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[常见知识归纳1. 盒子模型2. css 选择器3. css 三大特性4. css3 常用样式 1 盒子模型w3c： content, padding, border, margin ie: content, margin, 其中 content 包含了 padding 和 border 2 css 选择器id选择器(#myid)、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器（a:hover, li:nth-child） 3 css 三大特性继承、层叠性、权重 3.1 继承什么是继承？哪些样式可以继承？哪些样式不可以继承？ 继承：父节点具有某些属性样式，子节点没有设置这个样式，却能够表现出跟父节点相同的这个样式 可以继承的样式： font-size font-family (font 系列) color text-align text-decoration (text 系列) line-height 不可继承的样式： width padding border margin height 3.2 权重指一个节点，如果有多个相同的样式设定，如果确定采用哪一个? 优先级（就近原则）：!important &gt; 内联 &gt; [ id &gt; class &gt; tag ] !important 比内联优先级高 3.3 层叠性指同一个元素，可以设置多层样式，浏览器根据特定的层叠算法，计算出css样式对应的权重值，获胜的则应用到节点上。 4 css3 常用样式在编写CSS3样式时，不同的浏览器可能需要不同的前缀，这表示CSS属性或规则尚未成为W3C标准的一部分，是浏览器的私有属性，虽然目前较新的浏览器可能不需要前缀了了，但是为了更好的向前兼容前缀暂时还是不能少。 浏览器 前缀 chrome和safari -webkit firfox -moz IE -ms opera -o 4.1 border-radio 八个参数4.2 box-shadow 水平 垂直 模糊度 外延 颜色 inset4.3 text-shadow 水平 垂直 模糊度 颜色4.4 transparenttransparent是全透明黑色(black)的速记法，即一个类似rgba(0,0,0,0)这样的值。在CSS1中，transparent被用来作为background-color的一个参数值，用于表示背景透明。在CSS2中，border-color也开始接受transparent作为参数值。在CSS3中，transparent被延伸到任何一个有color值的属性上。 4.5 设置服务器端字体 @font-face12345@font-face&#123; font-family:name; src:url("fonts/Fontin_Sans_B_45b.otf") format("opentype"); font-weight:normal;&#125; //name用来声明使用服务端的字体。//format用来声明字体文件的格式，可以省略文件格式的声明而单独使用src属性值。字体文件的格式有哪些（OpenType与TrueType,前者的属性值为opentype，后者的属性值为truetype；前者的文件扩展名为.otf，后者的为.ttf）注：在IE中使用时，只能使用微软自带的Embedded OpenType字体文件，扩展名为.eot，同时不需要使用format属性值，用法如下1234@font-face&#123; font-family:BorderWeb; src:url(BORDERW0.eot);&#125; 最后通过 {font-family:name}来使用。 4.6 backgroundbackground-clip：border-box | padding-box | content-box | textpadding-box：从padding区域（不含padding）开始向外裁剪背景。border-box：从border区域（不含border）开始向外裁剪背景。content-box：从content区域开始向外裁剪背景。background-origin：padding-box|border-box|content-box该属性指定了背景从哪个区域(边框、补白或内容)开始绘制,但也仅仅能控制背景开始绘制的位置，你可以用这个属性在边框上绘制背景，但边框上的背景显不显示出来那就要由background-clip来决定了background-size:length：用长度值指定背景图像大小。不允许负值。percentage：用百分比指定背景图像大小。不允许负值。auto：背景图像的真实大小。cover：将背景图像等比缩放到完全覆盖容器，背景图像有可能超出容器。contain：将背景图像等比缩放到宽度或高度与容器的宽度或高度相等，背景图像始终被包含在容器内。 4.7 background-image 添加多张图片1234567div&#123; background-image:url(flower-red.png), url(flower-green.png),url(sky.jpg); background-repeat: no-repeat, repeat-x, no-repeat; background-position: 3% 98%,85%, center center, top; width: 300px; padding: 90px 0px; &#125; 注：第一个定义的背景图片在最上面的，最后定义的是在最下面的。使用background-repeat和background-position可以单独指定背景图像中某个文件的平铺方式与放置的位置]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
