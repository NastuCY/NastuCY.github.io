<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js运行机制]]></title>
    <url>%2F2019%2F02%2F13%2Fjs%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[大纲 进程与线程 浏览器是多进程的 浏览器包含哪些进程 多进程的优势 浏览器内核(渲染过程) Browser进程与浏览器内核（Renderer进程）的通信过程 梳理浏览器内核中线程的关系 GUI渲染线程与JS引擎线程互斥 JS阻塞页面加载 WebWorker,JS的多线程？ WebWorker与SharedWorker 浏览器的渲染过程 load事件与DOMContentLoaded事件的先后 css加载是否会阻塞dom树的渲染 普通图层和复合图层 从EvenLoop谈Js的运行机制 事件循环机制的进一步说明 单独说说定时器 setTimeout而不是setInterval 事件循环进阶：macrotask与microtask 区分线程与进程先看下进程与线程的一个比喻： 进程是一个独立的工厂，工厂有他独立的资源工厂之间相互独立线程是工厂里的工人,多个工人协同完成任务工厂内有一个或多个工人工人之间共享空间 完善一下： 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）工厂之间相互独立 -&gt; 进程之间相互独立多人协作共同完成任务 -&gt; 多个线程在进程中协作完成任务工厂内有一个或多个工人 -&gt; 一个进程有一个或多个线程组成工人之间共享空间 -&gt; 同一个进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等） 用官方一点的话进行总结是： 进程是CPU进行资源分配的最小单位（系统会给他分配内存），是能拥有资源和独立运行的最小单位 线程是CPU调度的最小单位（线程是建立在进程基础上的一次程序运行单位，一个进程可以有多个线程） tips 不同进程之间也可以通信，不过代价比较大 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。 浏览器是多线程的理解了进程与线程的区别后，接下来对浏览器进行一定程度的认识,先看下简化理解： 浏览器是多进程的 浏览器之所以能够运行，是因为系统给他的进程分配了资源（cpu、内存） 简单点理解，每打开一个tab页，就相当于创建了一个独立的浏览器进程。 注意:浏览器也有自己的优化机制，多个空白tab页打开后，会被合并。 浏览器包含了哪些进程?主要进程有：1.Browser进程：浏览器的主要进程（负责协调、主控）之有一个，作用有： 负责浏览器的页面展示 ，与用户交互，如前进、后退等。 负责各个页面的管理，创建和销毁其他进程。 将Renderer进程得到的内存中的Bitmap，绘制到用户界面。 网络资源的管理，下载等 2.第三方插件进程：每种类型的插件对应一个进程，仅当使用改插件时才创建。3.GPU进程：最多一个，用于3D绘制等。4.浏览器渲染进程：（浏览器内核）（Renderer进程，内部是多线程的）默认每个Tab页是一个进程，互不影响，主要作用为： 页面渲染，脚本执行，事件处理等。 在浏览器打开一个网页相当于起了一个进程（进程内有自己的多线程）。 浏览器多线程的优势相比于单线程的浏览器，多线程浏览器有以下优势： 避免单个page crash(页面崩溃)影响整个浏览器。 避免第三方插件崩溃影响整个浏览器。 多线程充分利用多核优势。 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性。 内存消耗有点大。空间换时间。 浏览器内核对于前端来说，最重要的进程是浏览器的渲染进程。页面的渲染，JS的执行，事件的循环，都在这个进程内执行。 请牢记，浏览器的渲染进程是多线程的。 浏览器的渲染进程包含哪些线程？（列一些常驻的）1.GUI渲染线程 负责渲染浏览器页面，解析HTML,CSS, 构建DOM树和RenderObject树，布局和重绘等。 当界面需要重绘（Repaint,样式改变）或由于某些操作引发回流（reflow）时，该线程就会执行。 注意，GUI渲染线程与JS引擎线程是互斥的，当js引擎执行时GUI线程会被挂起，（相当于被冻结了），GUI更新会被保存在一个队列中，等到JS引擎空闲时立即执行。 2.JS引擎线程 也称作JS内核，负责处理Javascript脚本程序（例如V8引擎）。 JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待任务队列中任务的到来，然后加以处理,一个Tab页（Renderer进程）中无论什么时候都只有一个JS线程在运行JS程序。 同样注意：GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行时间过程，就会造成页面渲染不连贯，导致页面渲染加载阻塞。 3.事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环。（可以理解为，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如SetTimeout时（也可以来自于浏览器的其他线程，如鼠标点击，Ajax请求等），会将对应任务添加到事件线程中。 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。 由于JS的单线程关系，所有这些待处理队列中的事件都得排队等待JS引擎处理。（当JS引擎空闲时才会去执行） 4.定时器触发线程 传说中的setTimeout与setInterval所在线程。 浏览器定时计数器并不是由js引擎计数的（因为js引擎是单线程的，如果处于阻塞线程状态就会影响计数的准确性） 因此通过单独的线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C与HTML标准中规定，规定要求setTimeout低于4ms的时间间隔算为4ms。 5.异步http请求线程 在XMLHttpRequest在连接之后通过浏览器新开一个线程请求。 在检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JS引擎执行。]]></content>
      <tags>
        <tag>js</tag>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node]]></title>
    <url>%2F2019%2F02%2F05%2Fnode%2F</url>
    <content type="text"><![CDATA[什么是NodeJs 编写高性能网络服务器的Javascript工具包(用JS开发服务端程序) 单线程、异步、事件驱动 特点：快，耗内存多 网上一个百万级并发测试，未优化的情况下1M的链接消耗了16G的内存]]></content>
      <tags>
        <tag>node</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js对象方法总结]]></title>
    <url>%2F2019%2F01%2F12%2Fjs%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Object.assign()通过复制一个或多个对象来创建一个新的对象。Object.create()使用指定的原型对象和属性创建一个新对象。Object.defineProperty()给对象添加一个属性并指定该属性的配置。Object.defineProperties()给对象添加多个属性并分别指定它们的配置。Object.entries()返回给定对象自身可枚举属性的[key, value]数组。Object.freeze()冻结对象：其他代码不能删除或更改任何属性。Object.getOwnPropertyDescriptor()返回对象指定的属性配置。Object.getOwnPropertyNames()返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。Object.getOwnPropertySymbols()返回一个数组，它包含了指定对象自身所有的符号属性。Object.getPrototypeOf()返回指定对象的原型对象。Object.is()比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。Object.isExtensible()判断对象是否可扩展。Object.isFrozen()判断对象是否已经冻结。Object.isSealed()判断对象是否已经密封。Object.keys()返回一个包含所有给定对象自身可枚举属性名称的数组。Object.preventExtensions()防止对象的任何扩展。Object.seal()防止其他代码删除对象的属性。Object.setPrototypeOf()设置对象的原型（即内部[[Prototype]]属性）。Object.values()返回给定对象自身可枚举值的数组。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>Object</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组方法总结]]></title>
    <url>%2F2018%2F08%2F12%2Fjs%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结的一些常用数组方法1. join()方法2. push()和pop()方法3. shift()和unshift()方法4. sort()方法5. reserve()方法6. concat()方法7. slice()方法8. splice()方法9. indexOf()和lastIndexOf()方法10. forEach()方法11. map()方法12. filter()方法13. every()方法14. some()方法15. reduce()和reduceRight()方法16. ES6对数组的拓展 1. join将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。1234var arr = [1,2,3];console.log(arr.join()); // 1,2,3console.log(arr.join("-")); // 1-2-3console.log(arr); // [1, 2, 3]（原数组不变） join() 方法，不会改变数组！返回值: 一个所有数组元素连接的字符串。如果 arr.length 为0，则返回空字符串 2. push和poppush(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。 1234567var arr = ["Lily","lucy","Tom"];var count = arr.push("Jack","Sean");console.log(count); // 5console.log(arr); // ["Lily", "lucy", "Tom", "Jack", "Sean"]var item = arr.pop();console.log(item); // Seanconsole.log(arr); // ["Lily", "lucy", "Tom", "Jack"] 3. shift和unshiftshift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。unshift():将参数添加到原数组开头，并返回数组的长度 。 1234567var arr = ["Lily","lucy","Tom"];var count = arr.unshift("Jack","Sean");console.log(count); // 5console.log(arr); //["Jack", "Sean", "Lily", "lucy", "Tom"]var item = arr.shift();console.log(item); // Jackconsole.log(arr); // ["Sean", "Lily", "lucy", "Tom"] 4. sortsort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面，默认排序顺序是根据字符串Unicode码点。 参数compareFunction | 可选用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。如果没有指明 compareFunction ，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。例如 “Banana” 会被排列到 “cherry” 之前。当数字按由小到大排序时，9 出现在 80 之前，但因为（没有指明 compareFunction），比较的数字会先被转换为字符串，所以在Unicode顺序上 “80” 要比 “9” 要靠前 如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素： 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）； 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 比较函数格式如下：12345678910function compare(a, b) &#123; if (a &lt; b ) &#123; // 按某种排序标准进行比较, a 小于 b return -1; &#125; if (a &gt; b ) &#123; return 1; &#125; // a must be equal to b return 0;&#125; 要比较数字而非字符串，比较函数可以简单的以 a 减 b，如下的函数将会将数组升序排列 123456789101112var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b) &#123; return a - b;&#125;);console.log(numbers);也可以写成：var numbers = [4, 2, 5, 1, 3]; numbers.sort((a, b) =&gt; a - b); console.log(numbers);// [1, 2, 3, 4, 5] 对象也可按照某个属性进行排序 返回值排序后的数组。请注意，数组已原地排序，并且不进行复制。 5. reservereverse()：反转数组项的顺序。 6. concatconcat(): 将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。 实现的是数组的浅拷贝。 7. sliceslice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。 参数begin | 可选 从该索引处开始提取原数组中的元素（从0开始）。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin，则 slice 从索引 0 开始。 end | 可选 在该索引处结束提取原数组元素（从0开始）。slice会提取原数组中索引从 begin 到 end 的所有元素（包含begin，但不包含end）。slice(1,4) 提取原数组中的第二个元素开始直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1)表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。如果 end 被省略，则slice 会一直提取到原数组末尾。如果 end 大于数组长度，slice 也会一直提取到原数组末尾 返回值 一个含有提取元素的新数组。 8. splicesplice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。 参数 array.splice(start[, deleteCount[, item1[, item2[, …]]]]) 返回值 splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组 12345678910var arr = [1,3,5,7,9,11];var arrRemoved = arr.splice(0,2);console.log(arr); //[5, 7, 9, 11]console.log(arrRemoved); //[1, 3]var arrRemoved2 = arr.splice(2,0,4,6);console.log(arr); // [5, 7, 4, 6, 9, 11]console.log(arrRemoved2); // []var arrRemoved3 = arr.splice(1,1,2,4);console.log(arr); // [5, 2, 4, 4, 6, 9, 11]console.log(arrRemoved3); //[7] splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 9. indexOf和lastIndexOfindexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。 123456var arr = [1,3,5,7,7,5,3,1];console.log(arr.indexOf(5)); //2console.log(arr.lastIndexOf(5)); //5console.log(arr.indexOf(5,2)); //2console.log(arr.lastIndexOf(5,4)); //2console.log(arr.indexOf("5")); //-1 10. forEachforEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；值对应的数组索引，数组本身。 参数callback为数组中每个元素执行的函数，该函数接收三个参数： currentValue数组中正在处理的当前元素。index | 可选数组中正在处理的当前元素的索引。array | 可选forEach()方法正在操作的数组。 thisArg | 可选可选参数。当执行回调 函数时用作this的值(参考对象)。 返回值undefined 注意： 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。如果你需要这样，使用forEach()方法是错误的，你可以用一个简单的循环作为替代。如果您正在测试一个数组里的元素是否符合某条件，且需要返回一个布尔值，那么可使用 Array.every 或 Array.some。如果可用，新方法 find() 或者findIndex() 也可被用于真值测试的提早终止。 如果数组在迭代时被修改了，则其他元素会被跳过。12345678910var words = ["one", "two", "three", "four"];words.forEach(function(word) &#123; console.log(word); if (word === "two") &#123; words.shift(); &#125;&#125;);// one// two// four forEach()不会在迭代之前创建数组的副本。 11. mapmap(): 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 参数callback生成新数组元素的函数，使用三个参数： currentValuecallback 数组中正在处理的当前元素。index | 可选callback 数组中正在处理的当前元素的索引。array | 可选callback map 方法被调用的数组。 thisArg | 可选执行 callback 函数时使用的this 值。 返回值一个新数组，每个元素都是回调函数的结果。 map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。map()同forEach()一样，无法跳出循环。 12. filterfilter():“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。 参数callback用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。返回true表示保留该元素（通过测试），false则不保留。使用三个参数： element当前在数组中处理的元素。index | 可选正在处理的当前元素的索引。array | 可选调用了filter的数组。 thisArg | 可选执行 callback 函数时使用的this 值。 返回值一个新的通过测试的元素的集合的数组，如果没有通过测试则返回空数组 filter 不会改变原数组，它返回过滤后的新数组。filter 遍历的元素范围在第一次调用 callback 之前就已经确定了。在调用 filter 之后被添加到数组中的元素不会被 filter 遍历到。如果已经存在的元素被改变了，则他们传入 callback 的值是 filter 遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。 12345678const fruits = ['apple', 'banana', 'grapes', 'mango', 'orange'];const filterItems = (query) =&gt; &#123; return fruits.filter((el) =&gt; el.toLowerCase().indexOf(query.toLowerCase()) &gt; -1 );&#125;console.log(filterItems('ap')); // ['apple', 'grapes']console.log(filterItems('an')); // ['banana', 'mango', 'orange'] 13. everyevery()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。 1234567function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true every 不会改变原数组。every 遍历的元素范围在第一次调用 callback 之前就已确定了。在调用 every 之后添加到数组中的元素不会被 callback 访问到。如果数组中存在的元素被更改，则他们传入 callback 的值是 every 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。every 和数学中的”所有”类似，当所有的元素都符合条件才返回true。另外，空数组也是返回true。(空数组中所有元素都符合给定的条件，注：因为空数组没有元素)。 14. somesome()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。 12[2, 5, 8, 1, 4].some(x =&gt; x &gt; 10); // false[12, 5, 8, 1, 4].some(x =&gt; x &gt; 10); // true some() 被调用时不会改变数组。 15 reduce和reduceRight这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值(initialValue)。 初始值可为[] 或者 {} 传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。 12345678const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15 数组去重 12345678let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];let result = arr.sort().reduce((init, current)=&gt;&#123; if(init.length===0 || init[init.length-1]!==current)&#123; init.push(current); &#125; return init;&#125;, []);console.log(result); //[1,2,3,4,5] 功能型函数管道 12345678910111213141516171819202122// Building-blocks to use for compositionconst double = x =&gt; x + x;const triple = x =&gt; 3 * x;const quadruple = x =&gt; 4 * x;// Function composition enabling pipe functionalityconst pipe = (...functions) =&gt; input =&gt; functions.reduce( (acc, fn) =&gt; fn(acc), input);//根据输入值，按顺序执行传入的函数，第一个函数的返回值当作第二个函数的参数值传入// Composed functions for multiplication of specific valuesconst multiply6 = pipe(double, triple);const multiply9 = pipe(triple, triple);const multiply16 = pipe(quadruple, quadruple);const multiply24 = pipe(double, triple, quadruple);// Usagemultiply6(6); // 36multiply9(9); // 81multiply16(16); // 256multiply24(10); // 240 16. ES6对数组的拓展16.1 拓展运算符复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。修改克隆数组，同时会导致原数组改变。 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 合并数组123456789const arr1 = ['a', 'b'];const arr2 = ['c'];const arr3 = ['d', 'e'];// ES5 的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 两种方法都为浅拷贝。 与解构赋值结合1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 字符串 扩展运算符还可以将字符串转为真正的数组。 12[...'hello']// [ "h", "e", "l", "l", "o" ] 实现了 Iterator 接口的对象Map 和 Set 结构，Generator 函数16.2 Array.from()Array.from()用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map） 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 数组去重合并 1234567function combine()&#123; let arr = [].concat.apply([], arguments); //没有去重复的新数组 return Array.from(new Set(arr));&#125; var m = [1, 2, 2], n = [2,3,3]; console.log(combine(m,n)); 16.3 Array.of()Array.of方法用于将一组值，转换为数组。创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 16.4 copyWithin()copyWithin()方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接收三个参数: target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 参数target,start和end 必须为整数。如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。copyWithin方法不要求其this值必须是一个数组对象；除此之外，copyWithin是一个可变方法，它可以改变this对象本身，并且返回它，而不仅仅是它的拷贝。copyWithin 就像 C 和 C++ 的 memcpy 函数一样，且它是用来移动 Array 或者 TypedArray 数据的一个高性能的方法。复制以及粘贴序列这两者是为一体的操作;即使复制和粘贴区域重叠，粘贴的序列也会有拷贝来的值。copyWithin 函数是设计为通用的，其不要求其 this 值必须是一个数组对象。The copyWithin 是一个可变方法，它不会改变 this 的 length，但是会改变 this 本身的内容，且需要时会创建新的属性。 1234567891011[1, 2, 3, 4, 5].copyWithin(-2);// [1, 2, 3, 1, 2][1, 2, 3, 4, 5].copyWithin(0, 3);// [4, 5, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 4);// [4, 2, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(-2, -3, -1);// [1, 2, 3, 3, 4] 16.5 find() 和 findIndex()find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 1234567891011121314[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2//接收第二个参数，用来绑定回调函数的this对象。function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: 'John', age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 16.6 fill()fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。返回修改后的数组。 接收三个参数： value :用来填充数组元素的值。 start | 可选 起始索引，默认值为0。 end | 可选 终止索引，默认值为 this.length。 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 16.7 entries()，keys() 和 values()三个方法都用于对数组的遍历。keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 不适用for...of遍历的情况下，可以手动调用遍历器对象的next方法，进行遍历12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 16.8 includes()includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。 arr.includes(searchElement, fromIndex) searchElement 需要查找的元素值。 fromIndex | 可选 从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length - fromIndex 的索引开始搜索。默认为 0。 12345[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, NaN].includes(NaN); // true 16.9 flat()和flatMap()flat() 方法会递归到指定深度将所有子数组连接，并返回一个新数组。 var newArray = arr.flat(depth) depth | 可选 指定嵌套数组中的结构深度，默认值为1。参数为Infinity时表示不管嵌套多少层，都转为一维数组。 flatMap()方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但flatMap通常在合并成一种方法的效率稍微高一些。 var new_array = arr.flatMap(function callback(currentValue[, index[, array]]) { // 返回新数组的元素}[, thisArg]) 123456789101112131415[1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5]// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8]//flatMap等价与reduce与concatvar arr1 = [1, 2, 3, 4];arr1.flatMap(x =&gt; [x * 2]);// 等价于arr1.reduce((acc, x) =&gt; acc.concat([x * 2]), []);// [2, 4, 6, 8] 如果原数组有空位，flat()方法会跳过空位。 16.10 数组的空位 forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 ES6 则是明确将空位转为undefined。 参考链接1.MDN Array2.阮一峰ECMAScript 6 入门]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ES6</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试文章]]></title>
    <url>%2F2018%2F01%2F12%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js基础]]></title>
    <url>%2F2017%2F07%2F22%2Fjs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[动态类型JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据。 数据类型最新的 ECMAScript 标准定义了 7 种数据类型: 6 种原始类型: Boolean有两个字面值 true和false Null值 null 是一个字面量，它不像undefined 是全局对象的一个属性。null 是表示缺少的标识，指示变量未指向任何对象。把null 作为尚未创建的对象，也许更好理解。在 APIs 中，null 常在返回类型是对象，但没关联值的地方使用。null表示一个空指针对象。 Undefined 一个没有被赋值的变量的类型是undefined，如果方法 Number String Symbol (ECMAScript 6 新定义) 和 Object 使用 typeof 操作符判断对象类型 # 参考链接1.MDN Array]]></content>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css笔记]]></title>
    <url>%2F2016%2F10%2F12%2Fcss%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[常见知识归纳1. 盒子模型2. css 选择器3. css 三大特性4. css3 常用样式 1 盒子模型w3c： content, padding, border, margin ie: content, margin, 其中 content 包含了 padding 和 border 2 css 选择器id选择器(#myid)、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器（a:hover, li:nth-child） 3 css 三大特性继承、层叠性、权重 3.1 继承什么是继承？哪些样式可以继承？哪些样式不可以继承？ 继承：父节点具有某些属性样式，子节点没有设置这个样式，却能够表现出跟父节点相同的这个样式 可以继承的样式： font-size font-family (font 系列) color text-align text-decoration (text 系列) line-height 不可继承的样式： width padding border margin height 3.2 权重指一个节点，如果有多个相同的样式设定，如果确定采用哪一个? 优先级（就近原则）：!important &gt; 内联 &gt; [ id &gt; class &gt; tag ] !important 比内联优先级高 3.3 层叠性指同一个元素，可以设置多层样式，浏览器根据特定的层叠算法，计算出css样式对应的权重值，获胜的则应用到节点上。 4 css3 常用样式在编写CSS3样式时，不同的浏览器可能需要不同的前缀，这表示CSS属性或规则尚未成为W3C标准的一部分，是浏览器的私有属性，虽然目前较新的浏览器可能不需要前缀了了，但是为了更好的向前兼容前缀暂时还是不能少。 浏览器 前缀 chrome和safari -webkit firfox -moz IE -ms opera -o 4.1 border-radio 八个参数4.2 box-shadow 水平 垂直 模糊度 外延 颜色 inset4.3 text-shadow 水平 垂直 模糊度 颜色4.4 transparenttransparent是全透明黑色(black)的速记法，即一个类似rgba(0,0,0,0)这样的值。在CSS1中，transparent被用来作为background-color的一个参数值，用于表示背景透明。在CSS2中，border-color也开始接受transparent作为参数值。在CSS3中，transparent被延伸到任何一个有color值的属性上。 4.5 设置服务器端字体 @font-face12345@font-face&#123; font-family:name; src:url("fonts/Fontin_Sans_B_45b.otf") format("opentype"); font-weight:normal;&#125; //name用来声明使用服务端的字体。//format用来声明字体文件的格式，可以省略文件格式的声明而单独使用src属性值。字体文件的格式有哪些（OpenType与TrueType,前者的属性值为opentype，后者的属性值为truetype；前者的文件扩展名为.otf，后者的为.ttf）注：在IE中使用时，只能使用微软自带的Embedded OpenType字体文件，扩展名为.eot，同时不需要使用format属性值，用法如下1234@font-face&#123; font-family:BorderWeb; src:url(BORDERW0.eot);&#125; 最后通过 {font-family:name}来使用。 4.6 backgroundbackground-clip：border-box | padding-box | content-box | textpadding-box：从padding区域（不含padding）开始向外裁剪背景。border-box：从border区域（不含border）开始向外裁剪背景。content-box：从content区域开始向外裁剪背景。background-origin：padding-box|border-box|content-box该属性指定了背景从哪个区域(边框、补白或内容)开始绘制,但也仅仅能控制背景开始绘制的位置，你可以用这个属性在边框上绘制背景，但边框上的背景显不显示出来那就要由background-clip来决定了background-size:length：用长度值指定背景图像大小。不允许负值。percentage：用百分比指定背景图像大小。不允许负值。auto：背景图像的真实大小。cover：将背景图像等比缩放到完全覆盖容器，背景图像有可能超出容器。contain：将背景图像等比缩放到宽度或高度与容器的宽度或高度相等，背景图像始终被包含在容器内。 4.7 background-image 添加多张图片1234567div&#123; background-image:url(flower-red.png), url(flower-green.png),url(sky.jpg); background-repeat: no-repeat, repeat-x, no-repeat; background-position: 3% 98%,85%, center center, top; width: 300px; padding: 90px 0px; &#125; 注：第一个定义的背景图片在最上面的，最后定义的是在最下面的。使用background-repeat和background-position可以单独指定背景图像中某个文件的平铺方式与放置的位置]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
