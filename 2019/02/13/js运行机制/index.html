<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">






  <meta name="keywords" content="js,js笔记,">










<meta name="description" content="大纲 进程与线程 浏览器是多进程的 浏览器包含哪些进程 多进程的优势 浏览器内核(渲染过程) Browser进程与浏览器内核（Renderer进程）的通信过程   梳理浏览器内核中线程的关系 GUI渲染线程与JS引擎线程互斥 JS阻塞页面加载 WebWorker,JS的多线程？ WebWorker与SharedWorker   浏览器的渲染过程 load事件与DOMContentLoaded事件的">
<meta name="keywords" content="js,js笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="js运行机制">
<meta property="og:url" content="http://yoursite.com/2019/02/13/js运行机制/index.html">
<meta property="og:site_name" content="陈岩的个人博客">
<meta property="og:description" content="大纲 进程与线程 浏览器是多进程的 浏览器包含哪些进程 多进程的优势 浏览器内核(渲染过程) Browser进程与浏览器内核（Renderer进程）的通信过程   梳理浏览器内核中线程的关系 GUI渲染线程与JS引擎线程互斥 JS阻塞页面加载 WebWorker,JS的多线程？ WebWorker与SharedWorker   浏览器的渲染过程 load事件与DOMContentLoaded事件的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/02/13/js运行机制/articlex.png">
<meta property="og:image" content="http://yoursite.com/2019/02/13/js运行机制/articlex1.png">
<meta property="og:image" content="http://yoursite.com/2019/02/13/js运行机制/articlex2.png">
<meta property="og:image" content="http://yoursite.com/2019/02/13/js运行机制/articlex3.png">
<meta property="og:image" content="http://yoursite.com/2019/02/13/js运行机制/articlex4.png">
<meta property="og:image" content="http://yoursite.com/2019/02/13/js运行机制/articlex5.png">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/1/12/16841bad1cda741f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/1/12/16841d6392e8f537?imageslim">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/1/12/16841d5f85468047?imageslim">
<meta property="og:updated_time" content="2019-03-20T03:13:09.752Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="js运行机制">
<meta name="twitter:description" content="大纲 进程与线程 浏览器是多进程的 浏览器包含哪些进程 多进程的优势 浏览器内核(渲染过程) Browser进程与浏览器内核（Renderer进程）的通信过程   梳理浏览器内核中线程的关系 GUI渲染线程与JS引擎线程互斥 JS阻塞页面加载 WebWorker,JS的多线程？ WebWorker与SharedWorker   浏览器的渲染过程 load事件与DOMContentLoaded事件的">
<meta name="twitter:image" content="http://yoursite.com/2019/02/13/js运行机制/articlex.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/02/13/js运行机制/">





  <title>js运行机制 | 陈岩的个人博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">陈岩的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/13/js运行机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenyans">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="陈岩的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">js运行机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-13T14:26:41+08:00">
                2019-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><ul>
<li>进程与线程</li>
<li>浏览器是多进程的<ul>
<li>浏览器包含哪些进程</li>
<li>多进程的优势</li>
<li>浏览器内核(渲染过程)</li>
<li>Browser进程与浏览器内核（Renderer进程）的通信过程</li>
</ul>
</li>
<li>梳理浏览器内核中线程的关系<ul>
<li>GUI渲染线程与JS引擎线程互斥</li>
<li>JS阻塞页面加载</li>
<li>WebWorker,JS的多线程？</li>
<li>WebWorker与SharedWorker</li>
</ul>
</li>
<li>浏览器的渲染过程<ul>
<li>load事件与DOMContentLoaded事件的先后</li>
<li>css加载是否会阻塞dom树的渲染</li>
<li>普通图层和复合图层</li>
</ul>
</li>
<li>从EvenLoop谈Js的运行机制<ul>
<li>事件循环机制的进一步说明</li>
<li>单独说说定时器</li>
<li>setTimeout而不是setInterval</li>
</ul>
</li>
<li>事件循环进阶：macrotask与microtask</li>
<li>190320补充：Node与浏览器的 Event Loop 差异</li>
</ul>
<a id="more"></a>
<h2 id="区分线程与进程"><a href="#区分线程与进程" class="headerlink" title="区分线程与进程"></a>区分线程与进程</h2><p>先看下进程与线程的一个比喻：</p>
<blockquote>
<p>进程是一个独立的工厂，工厂有他独立的资源<br>工厂之间相互独立<br>线程是工厂里的工人,多个工人协同完成任务<br>工厂内有一个或多个工人<br>工人之间共享空间</p>
</blockquote>
<p>完善一下：</p>
<blockquote>
<p>工厂的资源 -&gt; 系统分配的内存（独立的一块内存）<br>工厂之间相互独立 -&gt; 进程之间相互独立<br>多人协作共同完成任务 -&gt; 多个线程在进程中协作完成任务<br>工厂内有一个或多个工人 -&gt; 一个进程有一个或多个线程组成<br>工人之间共享空间 -&gt; 同一个进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</p>
</blockquote>
<p>用官方一点的话进行总结是：</p>
<ul>
<li>进程是CPU进行资源分配的最小单位（系统会给他分配内存），是能拥有资源和独立运行的最小单位</li>
<li>线程是CPU调度的最小单位（线程是建立在进程基础上的一次程序运行单位，一个进程可以有多个线程）</li>
</ul>
<p><strong>tips</strong></p>
<ul>
<li>不同进程之间也可以通信，不过代价比较大</li>
<li>现在，一般通用的叫法：<code>单线程与多线程</code>，都是指在一个进程内的单和多。</li>
</ul>
<h2 id="浏览器是多线程的"><a href="#浏览器是多线程的" class="headerlink" title="浏览器是多线程的"></a>浏览器是多线程的</h2><p>理解了进程与线程的区别后，接下来对浏览器进行一定程度的认识,先看下简化理解：</p>
<ul>
<li>浏览器是多进程的</li>
<li>浏览器之所以能够运行，是因为系统给他的进程分配了资源（cpu、内存）</li>
<li>简单点理解，每打开一个tab页，就相当于创建了一个独立的浏览器进程。</li>
</ul>
<p><strong>注意:</strong>浏览器也有自己的优化机制，多个空白tab页打开后，会被合并。</p>
<h3 id="浏览器包含了哪些进程"><a href="#浏览器包含了哪些进程" class="headerlink" title="浏览器包含了哪些进程?"></a>浏览器包含了哪些进程?</h3><p>主要进程有：<br>1.Browser进程：浏览器的主要进程（负责协调、主控）之有一个，作用有：</p>
<ul>
<li>负责浏览器的页面展示 ，与用户交互，如前进、后退等。</li>
<li>负责各个页面的管理，创建和销毁其他进程。</li>
<li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面。</li>
<li>网络资源的管理，下载等</li>
</ul>
<p>2.第三方插件进程：每种类型的插件对应一个进程，仅当使用改插件时才创建。<br>3.GPU进程：最多一个，用于3D绘制等。<br>4.浏览器渲染进程：（浏览器内核）（Renderer进程，内部是多线程的）默认每个Tab页是一个进程，互不影响，主要作用为：</p>
<ul>
<li>页面渲染，脚本执行，事件处理等。</li>
</ul>
<blockquote>
<p>在浏览器打开一个网页相当于起了一个进程（进程内有自己的多线程）。</p>
</blockquote>
<h3 id="浏览器多线程的优势"><a href="#浏览器多线程的优势" class="headerlink" title="浏览器多线程的优势"></a>浏览器多线程的优势</h3><p>相比于单线程的浏览器，多线程浏览器有以下优势：</p>
<ul>
<li>避免单个page crash(页面崩溃)影响整个浏览器。</li>
<li>避免第三方插件崩溃影响整个浏览器。</li>
<li>多线程充分利用多核优势。</li>
<li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性。</li>
</ul>
<p>内存消耗有点大。空间换时间。</p>
<h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><p>对于前端来说，最重要的进程是浏览器的渲染进程。<br>页面的渲染，JS的执行，事件的循环，都在这个进程内执行。</p>
<p>请牢记，<strong>浏览器的渲染进程是多线程的。</strong></p>
<p>浏览器的渲染进程包含哪些线程？（列一些常驻的）<br>1.GUI渲染线程</p>
<ul>
<li>负责渲染浏览器页面，解析HTML,CSS, 构建DOM树和RenderObject树，布局和重绘等。</li>
<li>当界面需要重绘（Repaint,样式改变）或由于某些操作引发回流（reflow）时，该线程就会执行。</li>
<li>注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，当js引擎执行时GUI线程会被挂起，（相当于被冻结了），GUI更新会被保存在一个队列中，等到JS引擎空闲时立即执行。</li>
</ul>
<p>2.JS引擎线程</p>
<ul>
<li>也称作JS内核，负责处理Javascript脚本程序（例如V8引擎）。</li>
<li>JS引擎线程负责解析Javascript脚本，运行代码。</li>
<li>JS引擎一直等待任务队列中任务的到来，然后加以处理,一个Tab页（Renderer进程）中无论什么时候都只有一个JS线程在运行JS程序。</li>
<li>同样注意：<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行时间过程，就会造成页面渲染不连贯，导致页面渲染加载阻塞。</li>
</ul>
<p>3.事件触发线程</p>
<ul>
<li>归属于浏览器而不是JS引擎，用来控制事件循环。（可以理解为，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li>
<li>当JS引擎执行代码块如SetTimeout时（也可以来自于浏览器的其他线程，如鼠标点击，Ajax请求等），会将对应任务添加到事件线程中。</li>
<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。</li>
<li>由于JS的单线程关系，所有这些待处理队列中的事件都得排队等待JS引擎处理。（当JS引擎空闲时才会去执行）</li>
</ul>
<p>4.定时器触发线程</p>
<ul>
<li>传说中的setTimeout与setInterval所在线程。</li>
<li>浏览器定时计数器并不是由js引擎计数的（因为js引擎是单线程的，如果处于阻塞线程状态就会影响计数的准确性）</li>
<li>因此通过单独的线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li>
<li>注意，W3C与HTML标准中规定，规定要求setTimeout低于4ms的时间间隔算为4ms。</li>
</ul>
<p>5.异步http请求线程</p>
<ul>
<li>在XMLHttpRequest在连接之后通过浏览器新开一个线程请求。</li>
<li>在检测到状态变更时，如果设置有回调函数，异步线程就产生<strong>状态变更事件</strong>，将这个回调再放入事件队列中，再由JS引擎执行。</li>
</ul>
<p><img src="/2019/02/13/js运行机制/articlex.png" alt="浏览器内核"></p>
<p>为什么JS引擎是单线程的？</p>
<blockquote>
<p>假设JS引擎是多线程的，现在有两个进程，processA、processB,现在要对同一个dom进行操作，同时进行操作，<br>processA编辑了该dom，processB删除了该dom，同时下达了两个矛盾的命令，浏览器该如何执行？</p>
</blockquote>
<h3 id="Browser进程（控制进程）和浏览器内核（Renderer进程）的通信过程"><a href="#Browser进程（控制进程）和浏览器内核（Renderer进程）的通信过程" class="headerlink" title="Browser进程（控制进程）和浏览器内核（Renderer进程）的通信过程"></a>Browser进程（控制进程）和浏览器内核（Renderer进程）的通信过程</h3><p>先打开任务管理器，然后打开一个浏览器，可以看到：任务管理器中出现了两个进程（一个是主控进程，一个是打开Tab页的渲染进程）<br>看下简化后的通信过程：</p>
<ul>
<li>Browser进程收到用户请求，首先要获取页面内容（比如通过网络下载资源），然后将该任务通过RendererHost接口传递给Render进程。</li>
<li>Renderer进程的Renderer接口接收到消息，简单解释后，交给渲染线程，然后开始渲染<ul>
<li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染。</li>
<li>可能有JS线程操作DOM（可能造成回流并重绘）。</li>
<li>最后Renderer进程将结果返回给Browser进程。</li>
</ul>
</li>
<li>Browser进程接收到结果并将结果绘制出来。</li>
</ul>
<p>一张简单的流程图：<br><img src="/2019/02/13/js运行机制/articlex1.png" alt="通信过程"></p>
<h2 id="梳理浏览器内核中线程之间的关系"><a href="#梳理浏览器内核中线程之间的关系" class="headerlink" title="梳理浏览器内核中线程之间的关系"></a>梳理浏览器内核中线程之间的关系</h2><h3 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h3><p>由于JS是可以直接操作dom的，如果修改这些元素属性的同时渲染页面（即JS线程和UI线程同时运行），那么渲染线程前后获取的元素属性可能就不一样了。<br>因此，为了防止不可渲染时出现不可预期的后果，浏览器设置GUI渲染线程与JS引擎为互斥关系，当JS引擎执行时，GUI线程会被挂起，GUI线程会被保存到一个待执行队列中等待JS引擎线程空闲时立即被执行。</p>
<h3 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载</h3><p>从上述的互斥关系中，我们可以推导出，JS如果执行时间过长，会阻塞页面的渲染。<br>尽量避免JS执行时间过长。</p>
<h3 id="WebWorker-js的多线程？"><a href="#WebWorker-js的多线程？" class="headerlink" title="WebWorker,js的多线程？"></a>WebWorker,js的多线程？</h3><p>JS对cpu密集型计算如何执行？<br>HTML5 中引入了Web Worker<br>MDN的官方解释是：</p>
<blockquote>
<p>Web Worker为web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。一个worker是使用一个构造函数创建的一个对象（e.g.Worker()）运行一个命名的Javascript文件。这个文件包含将在工作线程中运行的代码；workers运行在另一个全局上下文中，不同于当前window。因此，使用window快捷方式获取当前全局的范围（而不是self）在一个worker内将返回错误。</p>
</blockquote>
<p>这样理解下：</p>
<ul>
<li>创建Worker时，JS引擎像浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li>
<li>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</li>
</ul>
<p>所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，只等待计算结果出来后，将结果通信给主线程即可。</p>
<p>Worker可以理解是浏览器给JS引擎专门为大量计算问题开的小灶。</p>
<h3 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker</h3><ul>
<li>WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享<ul>
<li>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的Javascript程序。</li>
</ul>
</li>
<li>SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现。因为它不隶属于某个Render进程，可以为多个Render进行共享使用。<ul>
<li>所以Chrome浏览器为SharedWorker单独创建一个进程来运行Javascript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管他被创建多少次。</li>
</ul>
</li>
</ul>
<p>两个本质上就是线程与进程的区别。SharedWorker由独立的进程管理，WebWorker只是隶属与render进程下的一个线程。</p>
<h3 id="简单梳理下浏览器渲染流程"><a href="#简单梳理下浏览器渲染流程" class="headerlink" title="简单梳理下浏览器渲染流程"></a>简单梳理下浏览器渲染流程</h3><p>这个呢，渲染过程的前戏比较长，具体可以看下这个<a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a><br>可以省略概括为：</p>
<blockquote>
<p>浏览器输入url,浏览器主进程接管，开一个下载线程，然后进行http请求（略去DNS查询，IP寻址等操作），然后等待响应，获取内容，然后将内容通过RendererHost接口转交给Renderer进程，然后浏览器渲染开始。</p>
</blockquote>
<p>浏览器内核拿到内容后，渲染大概可以划分成以下步骤：</p>
<pre><code>1.解析HTML构建DOM树；
2.解析CSS构建render树，（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）；
3.布局render树（Layout/reflow）,负责各元素尺寸、位置的计算；
4.绘制render树（paint）,绘制页面像素信息；
5.浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。
</code></pre><p>这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。<br>“生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。<br><img src="/2019/02/13/js运行机制/articlex2.png" alt="渲染过程"><br>详细的步骤已经略去，渲染完毕后就是<code>load</code>事件，之后就是自己的JS逻辑处理了。<br>提一下这其中需要注意的一些细节。<br><code>重绘与重排</code><br>网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断渲染。<br>以下三种情况，会导致网页重新渲染：</p>
<ul>
<li>修改DOM</li>
<li>修改样式表</li>
<li>用户事件（鼠标悬停，页面滚动，输入框键入文字，改变窗口大小等等）</li>
</ul>
<p><strong>重新渲染，就需要重新生成布局和重新绘制，前者叫‘重排（reflow）’，后者叫‘重绘（repaint）’。</strong></p>
<p>需要注意的是，<strong>‘重绘’不一定需要‘重排’，</strong>比如改变某个网页元素的颜色，就只会触发‘重绘’，不会触发‘重排’，因为布局没有改变。但是，**‘重排’必然导致‘重绘’，比如改变一个元素的位置，就会同时触发‘重排’和‘重绘’，因为布局改变了。</p>
<p><code>关于性能优化</code>（后续补充）</p>
<h3 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h3><p>渲染完毕后会触发<code>load</code>事件，那么，load事件与DOMCotentLoaded事件的先后么？<br>它们的定义如下：</p>
<ul>
<li>当DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片。（比如如果有async加载的脚本就不一定完成）</li>
<li>当onload事件触发时，页面上的所有DOM，样式表，脚本，图片都已经加载完成了。</li>
</ul>
<p>所以，两者的顺序是：<code>DOMContentLoaded -&gt; load</code></p>
<h3 id="CSS加载是否会阻塞DOM树渲染？"><a href="#CSS加载是否会阻塞DOM树渲染？" class="headerlink" title="CSS加载是否会阻塞DOM树渲染？"></a>CSS加载是否会阻塞DOM树渲染？</h3><p>说下头部引入CSS样式的情况<br>首先，我们都知道：CSS是由单独的下载线程异步下载的。<br>然后，再说以下几个现象：</p>
<ul>
<li>CSS加载不会阻塞DOM树解析（异步加载时DOM照常构建）</li>
<li>但会阻塞render树渲染（渲染时等待css加载完毕，因为render树需要CSS信息）</li>
</ul>
<p>这可能也是浏览器的一种优化机制。</p>
<p>当你加载css的时候，可能会修改下面DOM节点的样式，如果CSS加载不阻塞render树渲染的话，那么当css加载完成之后，render树可能又得重新重绘或者回流了。这样就造成了一些不必要的损耗。所有干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完成之后，再根据最终的样式来渲染render树，这种做法性能方面会比较好一点。</p>
<h3 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h3><p>渲染步骤中提到了<code>composite</code>概念。<br>可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层和复合图层。</p>
<p>首先，普通文档流内可以理解为一个复合图层（这里称为默认符合层，里面不管添加多少元素，其实都是在一个复合图层中）</p>
<p>其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍属于默认复合图层。</p>
<p>然后，可以通过<code>硬件加速</code>的方式，声明一个新的复合图层，他会单独分配资源（当然也会脱离普通文档流，这样一个，不管这个复合图层中怎么变化，也不会影响默认复合层的回流重绘）</p>
<p>可以简单理解下：<strong>GPU中，各个复合图层是单独绘制的，所以互不影响</strong>，这也是为什么某些场景硬件加速效果一级棒。</p>
<p>可以在<code>Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders</code>中看到，黄色的就是复合图层信息。</p>
<h4 id="如何变成复合图层（硬件加速）"><a href="#如何变成复合图层（硬件加速）" class="headerlink" title="如何变成复合图层（硬件加速）"></a>如何变成复合图层（硬件加速）</h4><p>将该元素编程一个复合图层，就是传说中的硬件加速技术。</p>
<ul>
<li>最常用的方式：translated3d、translateZ</li>
<li>opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li>
<li>will-change属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其他属性并不会变成复合层）</li>
</ul>
<p>作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</p>
<ul>
<li>&#60;video&#62;&#60;iframe&#62;&#60;webgl&#62;等元素</li>
<li>其他，比如以前的falsh插件</li>
</ul>
<h4 id="absolute和硬件加速的区别"><a href="#absolute和硬件加速的区别" class="headerlink" title="absolute和硬件加速的区别"></a>absolute和硬件加速的区别</h4><p>可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。<br>所以，就算absolute中信息改变时不会改变普通文档流中render树。<br>但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。<br>（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）<br>而硬件加速直接就是另一个复合层了，（另起炉灶）所以它的信息改变不会影响默认复合层（内部肯定会影响属于自己的复合层），仅仅引发最后的合成。（输出视图）</p>
<h4 id="复合图层的作用？"><a href="#复合图层的作用？" class="headerlink" title="复合图层的作用？"></a>复合图层的作用？</h4><p>一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。<br>但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变得更卡。</p>
<h4 id="硬件加速时请使用z-index"><a href="#硬件加速时请使用z-index" class="headerlink" title="硬件加速时请使用z-index"></a>硬件加速时请使用z-index</h4><p>使用硬件加速时，请尽量可能的使用z-index，防止浏览器默认给后续的元素创建复合层渲染。</p>
<p>具体原理：<br><strong>wekit CSS3中，如果这个元素添加了硬件加速，并且z-index层级过低，那么在这个元素后面的其他元素（层级比这个元素高，或者相同的，并且releative或absolute属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能。</strong></p>
<p>简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转化为一个复合图层。</p>
<p>具体分析可参考这个连接 <a href="http://web.jobbole.com/83575/" target="_blank" rel="noopener">http://web.jobbole.com/83575/</a></p>
<h2 id="从Event-Loop谈JS的运行机制"><a href="#从Event-Loop谈JS的运行机制" class="headerlink" title="从Event Loop谈JS的运行机制"></a>从Event Loop谈JS的运行机制</h2><p>下面对JS引擎的一些运行机制进行分析。</p>
<p>注意，这里不谈<code>可执行上下文</code>，<code>VO</code>，<code>scop chain</code>等概念，这里主要结合<code>Event Loop</code>来谈JS代码是如何执行的。</p>
<p>读到这里之前已经了解到了JS引擎是单线程的，而且这里会用到上文中的几个概念：</p>
<ul>
<li>JS引擎线程</li>
<li>事件触发线程</li>
<li>定时器线程</li>
</ul>
<p>然后在理解一些概念：</p>
<ul>
<li>JS分为同步任务和异步任务</li>
<li>同步任务都是在主线程上执行，形成一个执行栈</li>
<li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li>
<li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li>
</ul>
<p><img src="/2019/02/13/js运行机制/articlex3.png" alt="执行过程"></p>
<p>看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其他代码。</p>
<h3 id="事件循环机制进一步补充"><a href="#事件循环机制进一步补充" class="headerlink" title="事件循环机制进一步补充"></a>事件循环机制进一步补充</h3><p>借助一张图来协助理解：<br><img src="/2019/02/13/js运行机制/articlex4.png" alt="事件循环"><br>上图大致描述是：</p>
<ul>
<li>主线程运行时会产生执行栈。</li>
</ul>
<p>栈中的代码调用某些API时，他们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）</p>
<ul>
<li>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调</li>
<li>如此循环</li>
<li>注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件</li>
</ul>
<h2 id="单独说说定时器"><a href="#单独说说定时器" class="headerlink" title="单独说说定时器"></a>单独说说定时器</h2><p>上述事件循环机制的核心是：JS引擎线程和事件触发线程<br>但事实上，还有一些隐藏的细节，比如调用setTimeout后，是如何等待特定时间后才添加到事件队列中的？<br>是JS引擎检测的么？当然不是了。它是由定时器线程控制的。<br>为什么要单独的定时器线程？<br>因为javascript引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确性，因此很有必要单独开一个线程用来计时。</p>
<p>什么时候会用到定时器线程？<br>当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p>
<p>比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p>
<p>这段代码的作用是当1000毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello!'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'begin'</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码的效果是最快时间内将回掉函数推入事件队列中，等待主线程执行。</p>
<p>注意：</p>
<ul>
<li>执行结果是：先begin后hello!</li>
<li>虽然代码的本意是0毫秒后推入事件队列，但是W3C在HTML标准中规定，要求setTimeout中低于4ms的时间间隔算为4ms。</li>
</ul>
<p>（不过也有一说是不同浏览器有不同的最小时间设定）</p>
<ul>
<li>就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin(因为只有可执行栈空了后才会主动读取事件队列)</li>
</ul>
<h3 id="setTimeout而不是setInterval"><a href="#setTimeout而不是setInterval" class="headerlink" title="setTimeout而不是setInterval"></a>setTimeout而不是setInterval</h3><p>用setTimeout模拟定时器时和直接用setInterval是有区别的。<br>因为每次setTimeout计时到后就回去执行，然后执行一段时间后才会继续setTimeout,中间就多了误差（误差与代码执行时间有关）<br>而setInterval则是每次都精确的间隔一个时间推入一个事件。（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）</p>
<p>而且setInterval有一些比较致命的问题就是：</p>
<ul>
<li>累计效应（上面提到的），如果setInterval代码再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔。就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一段时间）</li>
<li>而且把浏览器最小化显示等操作时，setInterval并不是执行程序，它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行。</li>
</ul>
<p>所以，鉴于这么多的问题，目前一般认为最佳的解决方案为：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame</p>
<p>补充：JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加，不过，仍然有很多的问题。</p>
<h2 id="事件循环进阶：macrotask和microtask"><a href="#事件循环进阶：macrotask和microtask" class="headerlink" title="事件循环进阶：macrotask和microtask"></a>事件循环进阶：macrotask和microtask</h2><p>先看下下面的这道题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure></p>
<p>它的正确执行顺序是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure></p>
<p>Promise里有一个新的概念：<code>microtask</code><br>或者，进一步，JS中分为两种任务类型：<code>macrotash</code>和<code>microtask</code>，在ECMA中，microtask称为<code>jobs</code>,macrotask可称为<code>task</code>。</p>
<p>它们的定义跟区别简单点可以按如下理解：</p>
<ul>
<li>mactask(又称为宏任务)，可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）<ul>
<li>每一个task从头到尾将这个任务执行完毕，不会执行其他的</li>
<li>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个task执行开始前，对页面进行重新渲染。<br>（task -&gt; 渲染 -&gt; task -&gt; …）</li>
</ul>
</li>
<li>microtask(又称为微任务)，可以理解是在当前task执行结束后立即执行的任务。<ul>
<li>也就是说，在当前task任务后，下一个task之前，在渲染之前。</li>
<li>所以它的相应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染</li>
<li>也就是说，在某一个macrotask执行完毕之后，将会在它执行期间产生的所有microtask都执行完毕（在渲染前）</li>
</ul>
</li>
</ul>
<p>分别什么样的场景会形成macrotask和microtask呢？</p>
<ul>
<li>macrotask：主代码块，setTimeout,setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）</li>
<li>microtask：Promise，process.nextTick等。</li>
</ul>
<p>补充：在node环境下，process.nextTick的优先级高于Promise,也就是可以简单理解为:在宏任务结束后会执行微任务队列中的nextTickQueue部分，然后才执行微任务中的Promise部分。</p>
<p>再根据线程理解下：</p>
<ul>
<li>macrotask中的事件都是放在一个事件队列里的，而这个队列有事件触发线程维护</li>
<li>microtask中的所有微任务都是添加到微任务队列（Job Queues）中的，等待当前macrotask执行完毕后执行，这个队列由JS引擎线程维护，</li>
</ul>
<p>所以，总结下运行规则：</p>
<ul>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>
</ul>
<p>如图：<br><img src="/2019/02/13/js运行机制/articlex5.png" alt="运行规则"></p>
<p>另外，请注意下Promise的polyfill与官方版本的区别：</p>
<ul>
<li>官方版本中，是标准的microtask形式。</li>
<li>polyfill,一般都是通过setTimeout模拟的，所以是macrotask形式</li>
<li>请特别注意两者的区别。</li>
</ul>
<p>注意，有些浏览器执行结果不一样，（因为他们可能吧microtask当成macrotask来执行了），但是为了简单，这里不描述一些不标准浏览器下的场景。</p>
<p>补充：使用MutationObserver实现microtask</p>
<p>MutationObserver可以用来实现microtask（它属于mocrotask，优先级小于Promise，一般Promise不支持时才会这样做）</p>
<p>它是Html5中的新特性，作用是：监听一个DOM变动，当DOM对象发生任何变动时，Mutation Observer会得到通知。<br>VUE核心代码采用是这种策略。</p>
<h2 id="190320补充：Node与浏览器的-Event-Loop-差异"><a href="#190320补充：Node与浏览器的-Event-Loop-差异" class="headerlink" title="190320补充：Node与浏览器的 Event Loop 差异"></a>190320补充：Node与浏览器的 Event Loop 差异</h2><p>浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/12/16841bad1cda741f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>接下我们通过一个例子来说明两者区别：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>浏览器端运行结果：<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></p>
<p>浏览器端的处理过程如下：<br><img src="https://user-gold-cdn.xitu.io/2019/1/12/16841d6392e8f537?imageslim" alt=""></p>
<p>Node端运行结果分两种情况：</p>
<ul>
<li><p>如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为<code>timer1=&gt;promise1=&gt;timer2=&gt;promise2</code></p>
</li>
<li><p>如果是node10及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。</p>
<ul>
<li>如果是第二个定时器还未在完成队列中，最后的结果为timer1=&gt;promise1=&gt;timer2=&gt;promise2</li>
<li>如果是第二个定时器已经在完成队列中，则最后的结果为timer1=&gt;timer2=&gt;promise1=&gt;promise2(下文过程解释基于这种情况下)</li>
</ul>
</li>
</ul>
<ol>
<li>全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；</li>
<li>首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；</li>
<li>至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2</li>
</ol>
<p>Node端的处理过程如下：<br><img src="https://user-gold-cdn.xitu.io/2019/1/12/16841d5f85468047?imageslim" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>浏览器和Node 环境下，microtask 任务队列的执行时机不同</p>
<ul>
<li>Node端，microtask 在事件循环的各个阶段之间执行</li>
<li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1.<a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a><br>2.<a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218" target="_blank" rel="noopener">浏览器与Node的事件循环(Event Loop)有何区别?</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/js/" rel="tag"># js</a>
          
            <a href="/tags/js笔记/" rel="tag"># js笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/05/node/" rel="next" title="node">
                <i class="fa fa-chevron-left"></i> node
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/26/你不知道的javascript随笔/" rel="prev" title="你不知道的javascript随笔">
                你不知道的javascript随笔 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/timg.jpg" alt="chenyans">
            
              <p class="site-author-name" itemprop="name">chenyans</p>
              <p class="site-description motion-element" itemprop="description">一个没有梦想的咸鱼。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/nastucy" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#大纲"><span class="nav-text">大纲</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#区分线程与进程"><span class="nav-text">区分线程与进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器是多线程的"><span class="nav-text">浏览器是多线程的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器包含了哪些进程"><span class="nav-text">浏览器包含了哪些进程?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器多线程的优势"><span class="nav-text">浏览器多线程的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器内核"><span class="nav-text">浏览器内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Browser进程（控制进程）和浏览器内核（Renderer进程）的通信过程"><span class="nav-text">Browser进程（控制进程）和浏览器内核（Renderer进程）的通信过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#梳理浏览器内核中线程之间的关系"><span class="nav-text">梳理浏览器内核中线程之间的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GUI渲染线程与JS引擎线程互斥"><span class="nav-text">GUI渲染线程与JS引擎线程互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JS阻塞页面加载"><span class="nav-text">JS阻塞页面加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebWorker-js的多线程？"><span class="nav-text">WebWorker,js的多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebWorker与SharedWorker"><span class="nav-text">WebWorker与SharedWorker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单梳理下浏览器渲染流程"><span class="nav-text">简单梳理下浏览器渲染流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#load事件与DOMContentLoaded事件的先后"><span class="nav-text">load事件与DOMContentLoaded事件的先后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS加载是否会阻塞DOM树渲染？"><span class="nav-text">CSS加载是否会阻塞DOM树渲染？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通图层和复合图层"><span class="nav-text">普通图层和复合图层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何变成复合图层（硬件加速）"><span class="nav-text">如何变成复合图层（硬件加速）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#absolute和硬件加速的区别"><span class="nav-text">absolute和硬件加速的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复合图层的作用？"><span class="nav-text">复合图层的作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#硬件加速时请使用z-index"><span class="nav-text">硬件加速时请使用z-index</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从Event-Loop谈JS的运行机制"><span class="nav-text">从Event Loop谈JS的运行机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件循环机制进一步补充"><span class="nav-text">事件循环机制进一步补充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单独说说定时器"><span class="nav-text">单独说说定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#setTimeout而不是setInterval"><span class="nav-text">setTimeout而不是setInterval</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件循环进阶：macrotask和microtask"><span class="nav-text">事件循环进阶：macrotask和microtask</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#190320补充：Node与浏览器的-Event-Loop-差异"><span class="nav-text">190320补充：Node与浏览器的 Event Loop 差异</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考链接"><span class="nav-text">参考链接</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenyans</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
